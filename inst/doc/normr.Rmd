---
title: "Introduction to the normR package"
author: "Johannes Helmuth"
date: "`r Sys.Date()`"
link:   http://bioconductor.org/packages/normr
output:
   BiocStyle::html_document:
      toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to the normR package}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# TL;DR (Too long; didn't read)

* `enrichR()` calls ChIP-seq enrichment over control for coordinate-sorted and
indexed bamfiles
```{r eval=FALSE}
e <- enrichR(treatment = "ChIP.bam",
             control   = "Control.bam",
             genome    = "hg19")
```

* `diffR()` calls differential enrichment between two conditions, *i.e.* two
ChIP-seq tracks
```{r eval=FALSE}
de <- diffR(treatment = "ChIP1.bam",
            control   = "ChIP2.bam",
            genome    = "hg19")
```

* `regimeR()` calls `k` enrichment regimes a ChIP-seq experiment over control
```{r eval=FALSE}
re <- regimeR(treatment = "ChIP.bam",
              control   = "Control.bam",
              genome    = "hg19",
              models    = k)
```

* `exportR()` writes above results to bed, bedGraph or bigWig
```{r eval=FALSE}
#export enriched regions with FDR<=10% for downstream analysis
exportR(obj      = e,
        filename = "enriched.bed",
        type     = "bed",
        fdr      = 0.1)
#or
#write normalized differential enrichment to bigWig for genome browser display
exportR(obj      = de,
        filename = "diffEnrichment.bw",
        type     = "bigWig")
```


# Introduction to normR

Chromatin immunoprecipitation followed by sequencing (ChIP-seq) provides
genome-wide localization data for DNA-associated proteins. To infer the
regions bound by such proteins the read densities obtained by such a ChIP-seq
experiment are compared to the corresponding read profile obtained by a
control experiment. A meaningful comparison requires normalization to
mitigate the effects of technical biases, e.g. different sequencing depth.
But more importantly the effect of the enrichment of certain regions on the
overall read statistics. Normalization requires knowledge of the regions that
remained unchanged, such that normalization and difference calling are
inseparable.

This package, *normR* (**n**ormR **o**beys **r**egime **m**ixture **R**ules),
follows this logic and performs normalization and difference calling
simultaneously to identify genomic regions enriched by the ChIP-procedure
(`normr::enrichR()`). In addition, normR enables the comparison between ChIP-seq
data obtained from different conditions allowing for unraveling genomic regions
that change their association with the ChIP-target (`normr::diffR()`). Lastly,
normR is capable to differentiate multiple regimes of enrichment, *i.e.* broad
domains and sharp peaks (`normr::regimeR`). In brief, all these routines
encompass three steps:

1. Count reads in fixed-size windows along the genome;
2. Fit a binomial mixture model by Expectation Maximization;
3. Assign each window a significance based on the fitted background component

This vignette explains a common workflow of normrR analysis on NGS data for
calling enrichment, identification of differential ChIP-seq enrichment and
stratification of enrichment regimes. Herein, we provide examples for the export of
results to common data formats like bigWig and bed. We show how analysis
statistics and diagnostic plots are helpful for studying results. In the last
section, we cover more advanced topics including fitting on defined regions,
*e.g.* promoters or integrating CNV information in differential ChIP-seq
enrichment calls.


# Toy Examples

## `enrichR()`: Calling Enrichment with an Input Control

In this first section, we would like to call regions significantly enriched
for reads in the ChIP-seq experiment given a Control alignment. Here, we analyze
ChIP-seq data for both H3K4me3 (pointy enrichment) and H3K27me3 (broad
enrichment) given an Input-seq control alignment originating from a human
immortalized myelogenous leukemia line (K562). Using normR, we show that our
representative region on human chromsome 1 (`chr1:22500000-25000000`) is
enriched for H3K4me3 mostly at promoters and precludes H3K27me3 enrichment which
is most apparent in inter-genic regions.

![](../inst/extdata/1a.png)
**IGV browser shot of Input (grey), H3K4me3 (green) and H3K27me3 (purple)
alignment data on chr1 22.5Mb to 25Mb with genes (black) drawn.**

As part of the normR package, we provide 3 alignment files in bam format (Input,
H3K4me3 and H3K27me3 ChIP-seq) containing reads for human chr1 22.5Mb to
25Mb. Note, bam files need to be sorted by read coordinates (`samtools sort
x.bam x_sorted.bam`) and indexed (`samtools index x_sorted.bam`). In the
following, we will call enriched regions in these data.

*Firstly*, we retrieve filepaths for toy data:

```{r}
#Loading required package
library(normr)

inputBamfile <- system.file("extdata", "K562_Input.bam", package="normr")
k4me3Bamfile <- system.file("extdata", "K562_H3K4me3.bam", package="normr")
k27me3Bamfile <- system.file("extdata", "K562_H3K27me3.bam", package="normr")
```

*Secondly and lastly*, we need to specify the genome of the alignment. The
`genome` argument can be a character specifying a UCSC genome identifier, *e.g.*
"hg19", or we can provide a 2-dimensional `data.frame` with columns seqnames and
length. We will follow the later option: You can generate a genome `data.frame`
yourself or can use `GenomeInfoDb` for retrieving the data.frame from UCSC for
given genome identifier:

```{r warning=FALSE}
#Fetch chromosome information
genome <- GenomeInfoDb::fetchExtendedChromInfoFromUCSC("hg19")

#Filter out irregular chromosomes and delete unnecessary columns
idx <- which(!genome$circular & genome$SequenceRole=="assembled-molecule")
genome <- genome[idx,1:2]
genome

#Toy data has only "chr1"
genome <- genome[genome[,1] == "chr1",]
genome
```

*Now*, we are all set to do a enrichment call with default parameters:

```{r warning=FALSE}
#Enrichment Calling for H3K4me3 and H3K27me3
k4me3Fit <- enrichR(treatment = k4me3Bamfile, control = inputBamfile, genome = genome, verbose = F)
k27me3Fit <- enrichR(treatment = k27me3Bamfile, control = inputBamfile, genome = genome, verbose = F)
```

That was easy and fast! You must know that all results are stored as `NormRFit` objects. They provide
convenient access to count data and fitting results. For example,
let's have a look at some simple fitting statistics for H3K4me3:

```{r}
k4me3Fit
```

The "Type" of the `NormRFit` object is defined by the function generating it,
*i.e.* `enrichR()`, `diffR()` or `regimeR()`.  $\theta^*$ (Theta^*) describes a
naive background parametrization if the effect of enrichment is not taken into
account. The actual $\theta_B$ is with $0.15$ much smaller than $\theta^*$ which
allows for more sensitive enrichment calling.  Furthermore, by looking at the
Mixture Proportions we find H3K4me3 is enriched in 6% of the windows. For
H3K27me3, we find 67% of the regions enriched.

```{r}
k27me3Fit
```

### Fitting statistics

Additionally, we can use some methods provide by the `NormRFit-class` to get a
grasp on the quality of our normR call, *e.g.* print a more concise summary that
gives in

All fitting results are a `NormRFit` object and provide some neat functions for
you to try out

```{r}
summary(k4me3Fit)
```

```{r, fig.show='hold', fig.cap="Density of enrichment", fig.width=5, fig.height=3}
#plot(k4me3Fit)
```

### Export of results


## `diffR()`: Calling Differential Enrichment without a Control Experiment

```{r}
```

## `regimeR()`: Identify Enrichment Regimes in ChIP-seq Experiments

```{r}
```


# Advanced Topics

## Change Read Counting Strategy with `BamCountConfig-class`

It is very important how we count reads contained in the bamfile.

## Analyzing Predefined Regions

Genomic Ranges of transcriptional start sites or putative transcription factor
binding sites etc

## Post-processing of Difference Calls with CNV information

## Recompute Significance Based on a User-defined Threshold


# For The ''`R`-lazy'': The `norm.R` Command Line Program

A lightweight RSCRIPT executale is part of the package and brings the
functionality described above to the command line.

```{r}
#get path to executable
inputBamfile <- system.file("extdata", "K562_Input.bam", package="normr")

```

