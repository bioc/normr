# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Group unique tupels from two integer vectors r and s
#'
#' @param r An \code{integer()}-vector If elements are not integers, they
NULL

#' @param s An \code{integer()}-vector. If elements are not integers, they 
NULL

#' Retrieve original vector of values with a supplied map
#'
#' When computing only on unique values, it is often desired to retrieve the
#' original ordering for output. This function does this by creating a new
#' numeric().
#'
#' @param vec The \code{numeric()}-vector to be mapped back
#' @param map The \code{integer()}-vector containg the maps
#' @return a \code{numeric()}-vector of mapped back values
#'
#' @seealso \code{\link{mapToUniquePairs}} for generation of map
NULL

#' @return a list with the following items:
#'        \item{values}{unique and sorted values of \code{r} and \code{s}}
#'        \item{map}{a vector such that 
#'                   \code{cbind(r,s)[i,] = values[,map[i]]} for every i}
#' @export
mapToUniquePairs <- function(r, s) {
    .Call('normr_mapToUniquePairs', PACKAGE = 'normr', r, s)
}

#' @export
mapToOriginal <- function(vec, map) {
    .Call('normr_mapToOriginal', PACKAGE = 'normr', vec, map)
}

#' Get normalized enrichment from a diffR fit
#'
#' @param posteriors posterior matrix as computed by diffR
#' @param r vector of counts in control
#' @param s vector of counts in treatment
#' @param k column index of background component in posteriors (DEFAULT=1)
#' @return a numeric with enrichment values in log space
#' @export
getEnrichment <- function(posteriors, r, s, k = 1L) {
    .Call('normr_getEnrichment', PACKAGE = 'normr', posteriors, r, s, k)
}

#' Deconvolute bivariate count data in multiple enrichment regimes. Bivariate
#'  data is modeled as a mixture of binomial distributions. Fitting is done
#'  with Expectation Maximization (EM).
#'
#' @param s \code{integer}-vector of counts (e.g. treatment counts in enrichment calls).
#'     If elements are not integers, they will be casted to integers.
#' @param r \code{integer}-vector of counts (e.g. control counts in enrichment calls).
#'     If elements are not integers, they will be casted to integers.
#' @param models \code{integer} specifying number of mixture components which should be
#'     >= 2 (default=2).
#' @param eps \code{double} specifying termination criterion for EM fit (default=0.001).
#' @param verbose \code{logical} specifying if logging should be performed (default=FALSE).
#' @param nthreads \code{integer} specifying number of cores to use (default=1).
#' @return a list with the following items:
#'        \item{qstar}{naive enrichment ratio \code{s/(r + s)}. Basis for EM fit.}
#'        \item{theta}{Parametrization for \code{models} binomial distributiions}
#'        \item{prior}{Mixture proportions for \code{models} binomial distributiions}
#'        \item{posterior}{Posteriormatrix over all bins for \code{models} binomial distributiions}
#'        \item{lnL}{log likelihood trace}
normr_core <- function(r, s, models = 2L, eps = .0001, iterations = 5L, bgIdx = 1L, verbose = FALSE, nthreads = 1L) {
    .Call('normr_normr_core', PACKAGE = 'normr', r, s, models, eps, iterations, bgIdx, verbose, nthreads)
}

